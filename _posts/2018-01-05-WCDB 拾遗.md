---
layout: post
title:  WCDB 拾遗
---

# 起因

最近开了个新项目，项目的主程童鞋引入了 `WCDB` 代替原先自撸的 `KeyValueStore` 和 `FMDB`。问为何，答曰：好用，线程安全又高效。又问具体实现细节，答曰：不懂，就是好用。所以作为一个负责任的前 `iOS` 开发决定花点时间扒一扒 `WCDB` 的实现。

`WCDB` 的 `Wiki` 介绍了它的三大特性：易用，高效和完整。通过 `ORM` 和 `WINQ`，`WCDB` 能提供非常简洁的数据访问接口，而通过整个框架的设计及局部代码优化则使得整体较为高效。下面主要扒一扒这两个特性如何达到。至于完整性，尤其是损坏修复由于涉及过多 SQLite 文件格式，考虑有空再细细研究。//如果有需求的话

# ORM 和 WINQ

在 `iOS` 上实现 `ORM` 并不是什么新鲜事。一般的流程是给定一个类，继承基类（非必须），通过 `runtime` 获取对应属性，并使用协议或基类方法以进行约束。以 [Realm](https://realm.io/cn/docs/objc/latest/#models) 为例，所有模型需要继承自 `RLMObject` 并通过重写基类方法指定主键，忽略属性等。当这种实现一般会有如下问题：

* 部分约束方法扔使用硬编码指定，有出错概率
* 约束表达力有限

同样以 `Realm` 为例，指定数据模型主键时，需要重写 `+ (NSString *)primaryKey` 方法返回属性名，此时不可避免使用硬编码字符串。同时像联合索引能高级用法也无法被 `Realm` 所支持。

而 `WCDB` 使用内建宏定实现 `ORM` 功能：将一个已有对象进行 `ORM` 绑定时，我们需要指定其遵守 `WCTTableCoding` 并通过各种内建宏完成绑定和约束。凭借着宏强大的表达力能够有效的避免上面的问题。

一个完整的 `WCTTableCoding` 协议如下

```objc

@protocol WCTTableCoding
@required
+ (const WCTBinding *)objectRelationalMappingForWCDB;
+ (const WCTPropertyList &)AllProperties;
+ (const WCTAnyProperty &)AnyProperty;
+ (WCTPropertyNamed)PropertyNamed; //className.PropertyNamed(propertyName)
@optional
@property(nonatomic, assign) long long lastInsertedRowID;
@property(nonatomic, assign) BOOL isAutoIncrement;
@end

```

其中和 `ORM` 关联最密切的自然是`objectRelationalMappingForWCDB` 这个方法，通过他返回类和数据库表的绑定关系，即 `WCTBinding`。而每一个 `WCTBinding` 又包含字段绑定关系(`WCTColumnBinding`)，约束绑定关系(`WCTConstraintBindingBase`)，索引绑定关系(`WCTIndexBinding`)，分别通过对应的宏实现：字段宏，约束宏和索引宏。关于几种宏的定义和使用可以参考[这里](https://github.com/Tencent/wcdb/wiki/ORM%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B)。

下面仅以 `WCTSampleORM` 中的例子来解释各个类型宏的作用，它的定义和实现如下：

```objc

@interface WCTSampleORM : NSObject

@property(nonatomic, assign) int identifier;
@property(nonatomic, retain) NSString *desc;
@property(nonatomic, assign) float value;
@property(nonatomic, retain) NSString *timestamp;
@property(nonatomic, assign) WCTSampleORMType type;

@end

@implementation WCTSampleORM

WCDB_IMPLEMENTATION(WCTSampleORM)
WCDB_SYNTHESIZE(WCTSampleORM, identifier)
WCDB_SYNTHESIZE_COLUMN(WCTSampleORM, desc, "description") //use "description" as column name in Database
WCDB_SYNTHESIZE_DEFAULT(WCTSampleORM, value, 1.0f)
WCDB_SYNTHESIZE_DEFAULT(WCTSampleORM, timestamp, WCTDefaultTypeCurrentTimestamp)
WCDB_SYNTHESIZE(WCTSampleORM, type)

WCDB_PRIMARY(WCTSampleORM, identifier)

@end

```

首先是 `WCDB_IMPLEMENTATION(WCTSampleORM)` 这个宏，展开后即是:

```objc

static WCTBinding _s_WCTSampleORM_binding(WCTSampleORM.class);
static WCTPropertyList _s_WCTSampleORM_properties;
+(const WCTBinding *) objectRelationalMappingForWCDB 
{ 
    if (self.class != WCTSampleORM.class) 
    { 
        WCDB::Error::Abort("Inheritance is not supported for ORM"); 
    } 
    return &_s_WCTSampleORM_binding; 
} 
+(const WCTPropertyList &)AllProperties 
{ 
    return _s_WCTSampleORM_properties; 
}
 +(const WCTAnyProperty &)AnyProperty
{
    static const WCTAnyProperty s_anyProperty(WCTSampleORM.class);
    return s_anyProperty; 
}
+(WCTPropertyNamed) PropertyNamed 
{
    return WCTProperty::PropertyNamed; 
}

```

单纯只关注 `objectRelationalMappingForWCDB` 的话，我们会发现宏无非做了一件事情：初始化名为 `_s_WCTSampleORM_binding` 的静态变量，并通过 `objectRelationalMappingForWCDB` 方法返回。

（这里有个小贴士，由于 `WCDB` 的宏定义较为复杂，推荐通过 `Xcode` [Product -> Perform Action -> Preprocess] 来预处理对应文件）

通过 `WCDB_IMPLEMENTATION` 宏，已经有了对应的协议实现，后续自然是怎么将模型字段和数据库表字段做关联，即通过 `字段宏` 将属性和数据库字段做意义关联。

## 字段宏

同样仅以

```objc
WCDB_SYNTHESIZE(WCTSampleORM, identifier)
```

为例，我们将这个宏展开，就得到了如下代码

```objc

+(const WCTProperty &)identifier 
{ 
    static const WCTProperty s_property( "identifier", WCTSampleORM.class, _s_WCTSampleORM_binding .addColumnBinding<decltype([WCTSampleORM new].identifier)>("identifier", "identifier"));
     return s_property; 
} 
static const auto _unused0 = [](WCTPropertyList &propertyList) 
{ 
    propertyList.push_back(WCTSampleORM.identifier); 
    return nullptr; 
}(_s_WCTSampleORM_properties);

```

这个宏做了两件事情：

* 生成属性同名静态方法，返回值为 `WCTProperty`，同时将字段绑定关系 `WCTColumnBinding` 加入  `_s_WCTSampleORM_binding`
* 通过匿名函数调用，将上一步返回值加入属性列表 `_s_WCTSampleORM_properties`

一个完整的列绑定关系包括如下字段：数据模型类名，绑定属性名，数据库字段名字，属性类型，都可以通过宏自动生成。
这里有两个比较 `tricky` 的写法：

* addColumnBinding 时使用了 decltype，同时传入的表达式为 [WCTSampleORM new].identifier，一方面可以使用这个特性在编译器检查属性拼写，如不慎将 `identifier` 误拼成 `identifie` 则会产生编译错误，这就规避了前面提到的硬编码问题，后续的一些宏处理也是同理，不赘述。另一方面通过属性类型可以动态选择不同的 `Accessor` 进行属性读取和设置。

* _unused0 实际是通过 "_unused" 和 __COUNTER__ 这个宏拼接而成，一方面通过 __COUNTER__ 可以保证当前文件中每个静态变量的唯一性，同时有可以在该静态方法初始化时调用对应的匿名函数，完成属性和绑定关系的添加。

上面的例子是一个简单的字段宏展开结果分析，`WCDB` 中也内置了几种较为复杂的的字段宏，如指定数据库字段名，指定默认值等用法，实现原理大同小异。指定数据库字段的做法无非是添加一个自定义字段名的宏定义，而指定默认则略微麻烦，需要通过宏定义生成另外一个以 `_s_WCTSampleORM_binding` 为参数匿名函数。
以 `WCDB_SYNTHESIZE_DEFAULT(WCTSampleORM, value, 1.0f)` 为例，展开后为

```objc

static const auto _unused3 = [](WCTBinding *binding) 
{ 
    binding->getColumnBinding(WCTSampleORM.value)->makeDefault<decltype([WCTSampleORM new].value)>( 1.0f);
    return nullptr; 
}(&_s_WCTSampleORM_binding);

```

通过字段宏已经可以完成一个 `ORM` 的雏形，而为了更快更强则还需要约束宏和索引宏的辅助。

## 约束宏
 
 `WCDB` 中的约束宏作用与 `SQLite` 中的约束基本是一一对应的关系，不同的约束，如主键，唯一，非空等约束都有其对应的宏定义。下面仅以主键宏为例，最简单的 ··

```objc

 static const auto _unused7 = [](WCTBinding *binding)
{ 
    binding->getColumnBinding(WCTSampleORM.identifier)->makePrimary(WCTOrderedNotSet, false, WCTConflictNotSet);
     return nullptr; }
(&_s_WCTSampleORM_binding);

```

同样是以匿名函数和静态变量的方式实现，通过 `_s_WCTSampleORM_binding` 查找 `WCTProperty` 对应的字段绑定关系




## 索引宏

# 线程安全和高性能






