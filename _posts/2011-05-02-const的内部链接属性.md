---
layout: post
title:  const的内部链接属性
---

最早注意到这个问题也是很偶然：某天发现工程里面有个头文件定义了一堆的字符常量：
{% highlight C++ %}
const std::string sKeyCode                  =    "code";        
const std::string sKeyResult                =    "result";      
const std::string sKeyResults               =    "results";
{% endhighlight %}

一时手贱，顺手把所有std:: string替换成了 char *，结果一跑：链接错误，XXXX重定义。百思不得其解，后来被人提醒这些变量都是全局变量啊，那用的时候应该是需要extern先声明一下。但是比较诡异的是:原来那种写法也是全局变量却不需要做另外的声明！

查了一下，才明白原来const是默认具有内部链接属性(internal linkage)，也就是说仅在定义这个变量的文件内可见，在链接时对外是不可见的。头文件里的全局常量实际上是include该头文件的CPP都有自己的一份额外的定义，而对于其他编译单元来说是透明的，不会造成重定义的链接错误。而改成const char\*    的写法就需要注意了：**这时候定义的只是一个指向常量字符串的普通指针而已，而不是常量指针。** 正确的写法应该是const char* const或者const char xx[]。

上面就是关于这个问题的一个简单分析，顺带顺藤摸瓜摸了些非主流的边角知识过来：

* const关键字具有内部链接属性，但是其“优先级”是低于extern的，如果我们以extern const int i = 0;这样的语法来定义一个常量i时，这个i是具有外部链接属性的，换而言之在使用时需要注意先用extern声明。
* 关于const修饰的变量地址：在通常情况下编译器是不会为const对象分配内存，只有在几种情况下会分配地址：
     * extern和const同时使用，使得变量具有了外部链接属性。
     * 对const对象取地址—-我们知道常量一般是放到符号表中的，所以上面的情况即使各个编译单元有自己的额外定义，但是实际上还是存放在同一个地方，并不占额外空间。而当我们的程序对const对象取地址的时候才会强制分配内存地址：不同CPP里面定义的相同常量一般来说对他们取地址得到的结果应该是一样的。(至少MSVC中是这样的结果)
     * runtime的const—-编译器是需要为它分配空间的，而且也不在符号表里面记录相关信息。


最后补一句关于const char\*这种写法的废话：const char\* p = “hello”和 char\* p = “hello”这两种写法表达的意思都一样：指向hello这个常量字符串的指针。从C语言时代起后一种写法就是如此，而到了C++时代，为了兼容以前的程序所以做了同样的规定，但是const char*这种写法相对而言更正规。
